#include <iostream>
#include <fstream>
#include <stdlib.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>

#define DELIMITER 1
#define VARIABLE  2
#define NUMBER    3
using namespace std;

char *prog; /* указатель на анализируемое выражение */
char token[80];
char tok_type;

double vars[26] = { /* 26 пользовательских переменных,  A-Z */
                    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                    0.0, 0.0, 0.0, 0.0, 0.0, 0.0
                  };

void eval_exp(double *answer), eval_exp2(double *answer);
void eval_exp1(double *result);
void eval_exp3(double *answer), eval_exp4(double *answer);
void eval_exp5(double *answer), eval_exp6(double *answer);
void atom(double *answer);
void get_token(void), putback(void);
void serror(int error);
double find_var(char *s);
int isdelim(char c);

/* Точка входа анализатора. */
void eval_exp(double *answer)
{
    get_token();
    if(!*token) {
        serror(2);
        return;
    }
    eval_exp1(answer);
    if(*token) serror(0); /* последня лексема должна быть нулем */
}

/* Обработка присваивания. */
void eval_exp1(double *answer)
{
    int slot;
    char ttok_type;
    char temp_token[80];
    
    if(tok_type == VARIABLE) {
        /* сохранить старую лексему */
        strcpy(temp_token, token);
        ttok_type = tok_type;
        /* вычислить индекс переменной */
        slot = toupper(*token) - 'A';
        
        get_token();
        if(*token != '=') {
            cin.putback(ttok_type); /* вернуть текущую лексему */
            /* восстановить старую лексему - это не присваивание */
            strcpy(token, temp_token);
            tok_type = ttok_type;
        }
        else {
            get_token(); /* получить следующую часть выражения */
            eval_exp2(answer);
            vars[slot] = *answer;
            return;
        }
    }
    eval_exp2(answer);
}

/* Сложение или вычитание двух слагаемых. */
void eval_exp2(double *answer)
{
    register char op;
    double temp;
    
    eval_exp3(answer);
    while((op = *token) == '+' || op == '-') {
        get_token();
        eval_exp3(&temp);
        switch(op) {
        case '-':
            *answer -= temp;
            break;
        case '+':
            *answer += temp;
            break;
        }
    }
}

/* Умножение или деление двух множителей. */
void eval_exp3(double *answer)
{
    register char op;
    double temp;
    
    eval_exp4(answer);
    while((op = *token) == '*' || op == '/' || op == '%') {
        get_token();
        eval_exp4(&temp);
        switch(op) {
        case '*':
            *answer *= temp;
            break;
        case '/':
            if(temp == 0.0) {
                serror(3); /* деление на ноль */
                *answer = 0.0;
            } else *answer /= temp;
            break;
        case '%':
            *answer = (int) *answer % (int) temp;
            break;
        }
    }
}

/* Возведение в степень */
void eval_exp4(double *answer)
{
    double temp, ex;
    register int t;
    
    eval_exp5(answer);
    if(*token == '^') {
        get_token();
        eval_exp4(&temp);
        ex = *answer;
        if(temp==0.0) {
            *answer = 1.0;
            return;
        }
        for(t=temp-1; t>0; --t)
            *answer *= (double)ex;
    }
}

/* Вычисление унарного + и -. */
void eval_exp5(double *answer)
{
    register char  op;
    
    op = 0;
    if((tok_type == DELIMITER) && *token=='+' || *token == '-') {
        op = *token;
        get_token();
    }
    eval_exp6(answer);
    if(op == '-') *answer = -(*answer);
}

/* Обработка выражения в скобках. */
void eval_exp6(double *answer)
{
    if((*token == '(')) {
        get_token();
        eval_exp2(answer);
        if(*token != ')')
            serror(1);
        get_token();
    }
    else atom(answer);
}

/* Получение значения числа или переменной. */
void atom(double *answer)
{
    switch(tok_type) {
    case VARIABLE:
        *answer = find_var(token);
        get_token();
        return;
    case NUMBER:
        *answer = atof(token);
        get_token();
        return;
    default:
        serror(0);
    }
}

/* Возврат лексемы во входной поток. */
void putback(void)
{
    char *t;
    
    t = token;
    for(; *t; t++) prog--;
}

/* Отображение сообщения о синтаксической ошибке. */
void serror(int error)
{
    static char *e[]= {
        "Syntax error",
        "Unbalanced parentheses",
        "No expression",
        "Division by zero"
    };
    cout << "%s\n" << e[error] << endl;
}

/* Получение очередной лексемы. */
void get_token(void)
{
    register char *temp;
    
    tok_type = 0;
    temp = token;
    *temp = '\0';
    
    if(!*prog) return; /* конец выражения */
    
    while(*prog!='\n'&& isspace(*prog)) ++prog; /* пропустить пробелы,
                  символы табуляции и пустой строки */
    
    if(strchr("+-*/%^=()", *prog)){
        tok_type = DELIMITER;
        /* перейти к следующему символу */
        *temp++ = *prog++;
    }
    else if(isalpha(*prog)) {
        while(!isdelim(*prog)) *temp++ = *prog++;
        tok_type = VARIABLE;
    }
    else if(isdigit(*prog)) {
        while(!isdelim(*prog)) *temp++ = *prog++;
        tok_type = NUMBER;
    }
    
    *temp = '\0';
}

// Возвращение значения ИСТИНА, если с является разделителем. 
int isdelim(char c)
{
    if(strchr(" +-/*%^=()", c) || c==9 || c=='\r' || c==0)
        return 1;
    return 0;
}
// Get the value of a variable.
double find_var(char *s)
{
    if(!isalpha(*s)){
        serror(1);
        return 0.0;
    }
    return vars[toupper(*token)-'A'];
}

int main(void)
{
    double answer;
    char *p;
    
    p = (char *) malloc(100);
    if(!p) {
        cin>>("Ошибка при выделении памяти.\n");
        exit(1);
    }
    
    /* Обработка выражений до ввода пустой строки. */
    do {
        prog = p;
        cout << "Please, enter the expression: ";
        gets(prog);
        if(!*prog) break;
        eval_exp(&answer);
        cout << "The result is: " << answer << endl;
    } while(*p);
    
    return 0;
}
